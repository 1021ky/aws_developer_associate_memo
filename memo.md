# memo

カテゴリごとにメモしていく

ほぼ[AWS サービス別資料](https://aws.amazon.com/jp/aws-jp-introduction/aws-jp-webinar-service-cut/)
の各資料からの引用であり、読んだことと思ったことを書いています。

## デプロイ

### AWS CodeCommit

* プライベートGitリポジトリをホストするマネージド型のソース管理サービス。
* Gitの標準機能をサポートしているため、既存のGitベースのツールとシームレスに連携する

### AWS CodeBuild

* フルマネージドなビルドサービスでソースコードのコンパイル、テスト実行、ソフトウェアパッケージの作成を実行
* 継続的なスケールと同時複数ビルドプロセス
* サーバーの管理は不要
* 利用した分のみ支払い（分単位の課金）
* Amazon CloudWatchによるモニタリング可能
* 一貫したイミュータブルな環境のために個々のビルドを新規Dockerコンテナで実行
  * memo github actionと似ている
* すべてのオフィシャルなAWS CodeBuildイメージにDockerとAWS CLIをインストール済み
* ニーズに応じてDockerイメージを作成することによってカスタムなビルド環境を提供可能

#### AWS CodeBuildの実行方法

* AWS Mangement Console
* AWS Command Line Interface
* AWS Tools and SDKs
* AWS CodePipeline

#### AWS CodeBuildの仕組み

* 実行されたらビルドプロジェクトでビルド環境を作成
* ビルドしたらAmazon Simple Storage Service（S3）にアップロード
* 必要があればAmazon Simple Notification ServiceやAWS Chatbotに通知する

#### ビルドの仕様

* ビルドの仕様はbuildspecファイルに記述するか、ビルドコマンドを書くか
* buildspec.yml
  * （必須）buildspecのバージョン: version
  * コマンドを実行するLinuxユーザー: run-as
    * 死してしない場合、すべてのコマンドがrootユーザーで実行される
    * phases ブロックでオーバーライド可能
      * memo ansibleと似ている
  * 環境変数: env
    * 環境変数には以下を指定可能
      * プレーンテキスト
      * AWS System Manager Parameter Storeの値
      * AWS Secrets Managerの値
    * 利用するシェル
      * Bash
      * Powershell.exe, cmd.exe
    * Git認証ヘルパーを利用するか
  * プロキシサーバー: proxy
    * アーティファクトのアップロード時、CloudWatchLogへのログ送信時にプロキシサーバを利用するか個別に定義可能
    * 明示的なプロキシサーバーを利用する場合、環境変数の設定が必要
      * HTTP_PROXY, HTTPS_PROXY, NO_PROXY
  * バッチビルド設定: batch
    * プロジェクトの同時実行と協調実行の定義を行う
      * batch/build-graph: バッチ内の他のタスクに依存する一連のタスクを定義（順次実行）
      * batch/build-list: 同時に実行されるタスクを定義
      * batch/build-matrix: さまざまな環境と並行して実行されるタスクを定義
  * （必須）実行するコマンド: phases
    * ビルドの各段階でCodeBuildが実行するコマンドを記述する
    * install
      * パッケージのインストールのみに利用することを推奨
      * runtime-versionsでランタイムを指定可能
    * pre_build
      * ビルド前に実行するコマンドを記述
      * Amazon ECRへのサインイン、npmの依存関係インストールなど
    * build
      * ビルド中に実行するコマンドを記述
    * post_build
      * ビルド後に実行するコマンドを記述
        * ビルドアーティファクトをjar, warにする
        * DockerイメージをAmazon ECRへPushなど
  * テストレポート作成: reports
    * テストレポートの作成をする
      * テストレポートとコードカバレッジレポートの2種類だせる
      * テストレポートは JunitXMLをはじめ、Cucumber JSON, NUnitXMLなど
      * コードカバレッジレポートは、JaCoCoXMLをはじめ、Clover XMLなど
  * AWS CodeBuildの出力: artifacts
    * CodeBuildの出力を定義する
    * アーティファクトの名前、アーティファクトに含めるサブディレクトリとファイルを指定する
    * secondary-artifactsを利用して、複数のビルド出力アーティファクトを定義することも可能
  * キャッシュ設定: cache
    * 複数のビルドホスト間で利用できるキャッシュを保存する
      * ソースキャッシュ
        * Gitメタデータをキャッシュ
        * コミット間の変更のみがPullされる
      * Dockerレイヤーキャッシュ
      * カスタムキャッシュ
        * ディレクトリ指定と限定になるがソースやDockerレイヤー以外の保存ができる
    * ダウンロードするよりも構築にコストがかかる小規模から中間ビルドアーティファクトに適したオプション
      * 大規模はネットワーク転送で時間がかかるので不適
      * Dockerのレイヤーキャッシュには最適ではない
    * S3、ローカル、キャッシュなしどれかを設定する



#### CodeBuildの機能

* ローカルマシンでビルドできる
  * docker Gitが必要
  * AWS CodeBuildエージェントを使用する
* AWS Session Managerでビルド環境へアクセスする
* CodeCommitやGitHubのマークダウンファイルに埋め込み、ビルドステータスを表示することが可能
* ステータスの通知
  * 通知ルールを設定してビルド状況の通知を受け取ることが可能
    * Amazon Simple Notification Service
      * memo ビルドができたら〜を実行というのがpub/sub形式でできるということかな
    * AWS Chatbot
* VPC内のリソースにアクセスする
  * EC2 Instanceとか
* 利用料金
  * インスタンスタイプがあって、それに応じて、メモリvCPUが変わり、ビルド時間あたりの課金も変わる


### AWS CodeDeploy

* ソフトウェアのデプロイを自動化するフルマネージド型のサービス
* Amazon EC2、AWS Lambda、オンプレミスサーバー、コンテナへの自動的なデプロイメント
* アプリケーションの複雑なアップデータの実施
* アプリケーションのデプロイ中のダウンタイムを回避
* エラーを検知すると自動的にロールバックを実行
* CodeDeployの利点
  * Push型だとDeploy先サーバーを知っている必要がある
  * Pull型デプロイができるCodeDeployはどんなサーバーが立っているか意識する必要はない
    * memo サーバーの台数増やすときにデプロイにつかうツールで変更が要らなくなるのもメリットだな


#### AWS CodeDeployの用語

* アプリケーション
  * デプロイするアプリケーションを一意に識別する名前
* コンピューティングプラットフォーム
  * アプリケーションがデプロイされるプラットフォーム
    * Amazon EC2
    * AWS Lambda
    * オンプレミスサーバー
    * コンテナ
    * Amazon ECS
* デプロイグループ
  * デプロイ環境の定義
  * Auto Scallingグループ
  * タグのグループ
    * EC2 インスタンス、オンプレミスインスタンス
  * ECSサービス

#### AWS CodeDeployのデプロイタイプ

* In-Place
  * 既存ノードのアセットを更新
    * 1台ずつ行う場合はローリングデプロイとも言う
  * EC2/オンプレミスで使用できる
    * ※オンプレミスでできるのはIn-Placeのみ
* Blue/Green
  * 新規にノードを構築し、デプロイ・テストあとにリクエストの振り分け先を変更
  * Lambda、ECS、EC2/オンプレミスで使用できる
* デプロイ設定
  * EC2/オンプレミス
    * One-at-a-time
      * 一台ずつ実施
    * Custom
      * healthy hosts（デプロイ前の無事に動いているホスト）を何%残してデプロイしていくか設定する
    * Half-at-a-time
      * healthy hosts（デプロイ前の無事に動いているホスト）を50残してデプロイ
    * All-at-once
      * 一度にすべてデプロイ
  * Lambda/ECS
    * Linear
      * 指定した割合で、指定した間隔をおいてデプロイする
        * 25%->10m passed -> 50% -> 10m passed -> 75% -> 10m passed -> 100%
    * Canary
      * 最初に指定した割合でデプロイする
      * デプロイしてから指定した時間が経過すると残りをデプロイ
    * All-at-once
      * 一度にすべてデプロイ

#### AWS CodeDeploy リビジョンとターゲットリビジョン

* リビジョン
  * EC2
    * ソースコード、Webページ、スクリプトなどとAppSpecファイルをまとめたアーカイブ
  * Lambda
    * Lambdaデプロイ用のAppSpecファイル
  * ECS
    * ECSデプロイ用のAppSpecファイル
* ターゲットリビジョン
  * リポジトリにアップロードした直近のリビジョン
  * デプロイグループへデプロイする対象
  * 自動デプロイで取得されるリビジョン
* サービスロール
  * CodeDeployに付与するIAMロール
    * CodeDeployからAWSリソースを操作するために必要
  * IAMインスタンスプロファイル
    * EC2インスタンスに付与するIAMロール
    * S3から配布物を取得できるようになるyaru`ya

#### CodeDeploy デプロイメント




### AWS X-Ray

### Amazon CloudWatch※

### AWS CodePipeline

### Amazon API Gateway

#### Amazon API Gatewayの位置づけ

+ インフラの管理（可用性とスケーラビリティ）
+ APIの管理（設定やデプロイの制御）
+ 認証と認可（アクセスの制御）
+ 流量制御と保護（スロットリング）

* バックエンドとなるもの
  * AWS Lambda
  * HTTPアクセス先
  * 各種AWSサービス
  * インターネット（外部Web）
#### Amazon API Gatewayの主なユースケース概要


+ インターネットからアクセス可能なパブリックなWebAPIの基盤を提供する
+ インターネットからアクセス可能なプライベートなWebAPIの基盤を提供する
+ AWSサービス（例：Amazon DynamoDBなど）を独自のWebAPI化する手段として利用する
+ サーバレスアーキテクチャを実現する手段として利用する

#### API Gatewayが扱うAPI

* REST
  * ステートレス（基本的には）
  * 単一HTTPメッセージでデータそう純真
* WebSocket
  * ステートフル
  * 1つのコネクションで継続的なデータ送受信が可能

#### API Gatewayが扱うAPI-RESTエンドポイントタイプ

* 3種類のエンドポイントタイプから1つを選択
* エッジ最適化
  * 一旦エッジロケーション（CloudFrontディストリビューション）にルーティング
* リージョン
  * リージョンに直接ルーティング
  * リクエスト元が同一リージョンの場合はレイテンシ軽減
  * CloudFrontとの組み合わせ可能
* プライベート
  * Publicからのアクセスはできず、VPC内からAWS PricateLink = VPCエンドポイント経由でのみアクセス可能

#### API設定　デプロイとステージ

* APIはステージにデプロイすることでクライアントから呼び出し可能になる
  * ステージとはprod, staging, devのこと
  * ステージ名はエンドポイントURL（パス）の一部として使用される
    * 例: https://{APIサービス名}/dev/...

#### API作成の流れ

* RESTのAPI新規作成の場合（統合先との結合部分で設定と、APIとしてのリクエストレスポンスを設定する）
  * 既存APIクローン or Swagger（OpenAPI）のファイルをインポート
    * Swagger（OpenAPI）のファイルをインポート
      * API Gateway固有の定義はx-amazon-apigateway-*で指定可能
  * リソースとメソッドを設定
    * 認証の設定などもここで行う
    * リクエスト時にAPIキー(HTTPヘッダx-api-keyで指定可能)を必須とするかどうか
  * 統合リクエストの設定
    * バックエンドへのリクエストに関する設定
      * ルーティング先バックエンドの指定、リクエストの変換など
      * バックエンドの種別として「lambda関数」、「HTTP」、「Mock」、「AWSサービス」、「VPCリンク」から選択
  * 統合レスポンス
    * バックエンドからのレスポンスに関する設定
      * レスポンス内容の変換やステータスコードのマッピングなど
        * 変換：xml->jsonなど
      * （統合リクエストに「統合プロキシ」を指定した場合などは設定不可）
  * メソッドレスポンス
    * リクエストに対する最終的なAPI Gatewayとしてのレスポンスに関する設定
      * どういうステータスコードやHTTPレスポンスヘッダを返すかなど
* 監視としてAPIダッシュボードがある
  * API呼び出し、レイテンシー、統合のレイテンシー（バックエンドとのやり取りに要した時間）
  * 4xxエラー、5xxエラー
* WebSocketの場合
  * WebSocketの状態に関するイベントを「ルート（Route）として定義」
  * 3つの事前定義ルートに加えてメッセージに応じたルートを指定可能
  * 3つの「ルート」を事前定義する
    * WebSocket接続・切断時の処理・デフォルトの処理
    * ただし、3つ意外に、カスタムルートを定義することもできる（メッセージのJSONデータによってカスタムルートが決まる）
  * API設定-ルート設定-
    * ルートリクエスト
      * 接続時のルートの場合は、認証の有無。APIキー必須
      * 切断時のルートの場合は、設定項目なし
      * それ以外のルートの場合、「モデル選択式を指定」
  * 統合リクエストの設定（RESTと同様）
    * バックエンドへのリクエストに関する設定
      * ルーティング先バックエンドの指定、リクエストの変換など
      * バックエンドの種別として「lambda関数」、「HTTP」、「Mock」、「AWSサービス」、「VPCリンク」から選択
    * 結合レスポンス
      * レスポンスキーとそれに対応するテンプレート選択式およびテンプレートキーとテンプレートのセットを複数指定可能
* 監視としてのAPIダッシュボードはWebSocketにもある
  * Message Count
  * Connection Count
  * 統合のレイテンシー
  * Client Errors
  * Integration Errors（統合先から4xx/5xxが帰ったリクエストの数）
  * Execution Errors（結合先呼び出し時のエラー数）


#### その他の主要機能

* API認証認可
  * IAMアクセス制限
    * IAMユーザーのクレデンシャル情報を利用してリクエストに署名データを指定
    * CognitioフェデレーテッドID認証IAMロールのアクセス権を使う場合もこの認証方式を選択する
  * Lambdaオーソライザー
    * 認証処理を委譲するLambda関数を指定してAPIへのアクセスを制御
      * 認証成功時にプリンシパルIDとそのポリシードキュメントを返す仕様
    * 独自の認証方式やOAuthなどの認証方式を組み込む方法として利用
  * Cognitioオーソライザー
    * 指定したCognitioユーザープールを元に事前に認証
* APIキーと使用量プラン
  * APIキーと使用量プランによりAPIのメータリングとスロットリングを実現する
  * APIクライアントからはAPIキー文字列を含めてリクエスト
  * 使用量プランでしきい値を超えたら429Too Many Requestsエラーを返す
    * 使用量プランでは、クォータ（呼び出し回数制限）の設定が可能
  * ※APIキーは認証目的に利用しない
    * あくまで計測のための識別用途
* スロットリング
  * サーバー側のスロットリング制限とクライアント側のスロットリング制限がある
  * クライアント側（API Gatewayへの）のスロットリング制限：使用量プランが設定されていたら、API・ステージ・メソッドでスロットリング設定
  * サーバー側（結合先への）のスロットリング制限：API・ステージ別のスロットリング設定。アカウント全体でレートやバーストを設定する
* ログとモニタリング
  * API/ステージ単位で「実行ログ」と「アクセスログ」をCloud Watch Logsに出力可能
    * memo これは便利ログ集約いれるときにたいへんだものね
    * ログ形式は Common Log Format/JSON/CSV/XML形式が予め用意されている
    * メトリクス：4xx/5xxなどのステータスコードのエラー数, Latency、接続数もとれる
* カスタムドメイン設定
* キャッシュ設定
* リソースポリシー設定
  * アクセス元を制限
  * キャッシュ無効化操作
* カナリアリリース
* AWS WAFとの関連付け
  * SQLインジェクションやXSSなどの攻撃から保護
  * アクセスポリシーや認証などの前にAWS WAFのWebACL（Access Control List）
* AWS X-Ray連携
  * REST APIではAPIステージのログ設定としてAWS X-Rayへの連携によるリクエストのトレースと分析及びデバッグが可能
  * 利用開始はAWS X-Rayへの連携を有効化するだけ
  * X-Ray側でサンプリングレートを設定してデータ量を調整可能
* クライアント証明書
  * HTTPエンドポイントタイプを結合リクエストの結合タイプで利用する際に、API Gatewayからのアクセスであることを示すクライアント証明書を作成・利用可能
* クライアントSDK
  * APIステージ単位でREST API呼び出しクライアントをSDKとして生成可能
* 利用料金
  * 最低利用料金や初期費用はない
  * API料金とデータ転送料金（EC2料金に準ずる）と併用サービスがあればその料金がかかる
  * API料金
    * REST API：コール数 + キャッシュメモリ量
    * WebSocket API：メッセージ要求数 + 継続時間

### Amazon CloudFront

* ユースケース
  * 大容量の配信や大量アクセスがあるサイトでの活用
  * 小規模でもWAF/DDoSなどのセキュリティ対策が必要なサイト
* Contents Delivery Networkのマネージドサービス
  * 高性能な分散配置
    * memo 各国に拠点持っているからやれるんだろうな
  * 高いパフォーマンス
  * キャパシティアクセスからの開放（予測不可能なスパイクアクセスへの対応）
  * ビルトインのセキュリティ機能（WAF連携・DDoS対策）
  * 充実したレポーティング（ログ・ダッシュボード・通知機能）
  * 完全従量料金
* キャッシュ機能
  * キャッシュコントロール機能あり
  * 動的コンテンツであっても、Header, Cookie, Query Strings情報をフォワードすることで動的なページのキャッシュも設定できる
* レポート機能で以下を見れる
  * キャッシュの統計情報
  * リアルタイムモニタリングと通知
  * 人気コンテンツの統計情報
  * リファラーの統計情報
  * リクエスト数およびデータ転送量
  * クライアントデバイスの統計情報
* アクセスログ
  * CloudFrontのアクセスログ
  * 任意のS3 Bucketに出力可能
  * アクセスログの出力はタイムラグあり
* ログとレポート
  * Access Log
    * 複雑なアクセスや利用傾向分析
    * データの可視化と詳細な障害分析
    * S3->Amazon Athena->Amazon QuickSightで実現可能
  * リアルタイムモニター
    * 障害/異常検知や現状の利用確認に
    * CloudWatchで実現可能
  * レポーティング
    * アクセスや利用状況傾向の確認及び分析
    * Management Consoleで実現可能
* AWS Lambda@Edge
  * Amazon CloudFrontとAWS Lambdaで構成したもの
  * ユースケース
    * キャッシュヒット率の向上
    * コンテンツ生成をエッジで実行
      * 画像リサイズ、HTMLページ生成
      * A/Bテスト
    * セキュリティ
      * JWT/MD5/SHAトークンハッシュを使用した認証
      * HSTS/CSPセキュリティヘッダ付与

### Amazon DynamoDB

#### Amazon DynamoDB 特徴

* 完全マネージド型のNoSQLデータベースサービス
* ハイスケーラブル
* 高可用性（3箇所のAZに保存されるため信頼性が高い）
* シンプルかつパワフルなAPI
* ストレージの容量制限がない
  * 使った分だけの従量課金制のストレージ
* 運用管理必要なし
* プロビジョンドスループット
  * テーブルごとにReadとWriteそれぞれに対し、必要な文だけのスループットキャパシティを当てる（プロビジョンする）ことができる
* 整合性モデル
  * Write
    * 少なくとも2つのAZでの書き込み完了が確認取れた時点でAck
  * Read
    * デフォルト
      * 結果整合性のある読み込み
        * 結果整合性：最終的にその項目へのすべてのアクセスが最後に更新された値を返すこと
          * 更新データが即時判定されている保証はない
        * 完全一貫性: ACID準拠でトランザクションの信頼性が高い
          * 更新データがあったら、更新は反映されたものを読み込めるようにしている

#### Amazon DynamoDB 料金

* プロビジョンドスループットとストレージ利用料で決まる
  * プロビジョンドスループットは、Read/Writeそれぞれプロビジョンしたスループットによって時間あたりの料金が決まる
    * Read: $0.00742 50ユニットの読み込み容量あたり/1時間
      * 1ユニットは最大4KBのデータを1秒に1回読み込み可能
        * memo ざっくり計算で1000文字くらいか
        * 強い一貫性を持たない読み込み（結果整合性）であれば1秒あたり2回読み込み可能
    * Write: $0.00742 10ユニットの読み込み容量あたり/1時間
      * 1ユニットは最大1KBのデータを1秒に1回書き込み可能ということ
  * ストレージ利用料金は月当りはじめの25GBは無料

#### Amazon DynamoDB ユースケース

* KVS
  * ユーザー情報を格納するデータベース
* 広告やゲームなどのユーザー行動履歴DBとして
  * ユーザーIDごとの複数の行動履歴を管理するためのデータベース
* モバイルアプリのバックエンド
  * モバイルアプリから直接参照できるデータベースとして
* その他
  * バッチ処理のロック管理
  * フラッシュマーケティング（商品やサービスの提供にあたり、割引価格や特典がついたクーポンを期間限定でインターネット上で販売する手法）
  * ストレージのインデックス（？）

#### Amazon DynamoDBを使い始めるときにすること

+ テーブルのKeyやIndexを決める
+ Read/Writeそれぞれのスループットを決める
+ DynamoDB Streams設定を決める

#### DynamoDBの使い方

* DynamoDBの操作はHTTPベースのAPIで行う
  * Table API
    * [Create|Update|Delete|Describe]Table
    * ListTables
    * Query
      * Partation KeyとSort Keyの複合条件にマッチするアイテム群を取得
      * 最大1MBのデータを取得可能
    * Scan
      * テーブルを総なめする
      * 最大1MBのデータを取得可能
    * Batch[Get|Write]Item
      * Get 複数のプライマリキーを指定してマッチするアイテム群を取得
      * Write 書き込みか削除をいっかつで行う
    * [Get|Put|Update|Delete]Item
      * GetはPartation Keyを条件として指定し、1件のアイテムを取得
      * その他は1件のアイテムの書き込み/更新/削除
  * Stream API
    * Liststreams
    * DescribeStream
    * GetShardIterator
    * GetRecords
  * GetItem、Query、ScanにはConsistent Readというオプションを指定することができ、これを利用するとReadリクエストを受け取るよりも前に成功しているWriteリクエストが反映された結果が返る
    * Read Capacity Unitを通常の2倍消費する
  * Conditional Write
    * キーにマッチするレコードが存在したら/しなかったら、や、この値が〜以上/以下だったらという条件付き書き込み/更新ができる
  * Filter四季による結果の絞り込み
    * QueryまたはScanでは必要に応じてフィルタ式を指定して、返された結果を絞り込むことができる
    * Query、Scanの1MBの制限はフィルタ式の適用前に適用
    * 消費されるキャパシティユニットもフィルタ式を指定しなくても同じ
  * UpdateItemにおけるAttributeへの操作
    * Attributeに対して、UpdateItemでPut、Add、Deleteという3種類の操作が可能
      * Put Attributeを指定した値で更新
      * Add AttributeがNumber型なら足し算/引き算、Set型ならそのセットに対して値を追加する
      * Delete 当該Attributeを削除する
  * Atomic Counter
    * UpdateItemのAttribute Addを利用することで、Atomicなカウンターを実現することもできる


* テーブル構成
  * table ∋ items ∋ attibutes
  * table
    * Partation KeyとSort Keyがある
      * Partation Keyをプライマリキーとすることと、Partation KeyとSort Keyをプライマリキーとすることができる
    * Partation Keyは必須で、キーバリュー型のアクセスパターン。データ分散に利用される
    * Sort Key 1:Nモデルのリレーションシプでキー検索（betweenや不等号など）がQueryでできる
      * デフォルトの並べ替え順序は昇順
  * itemが1つの行
  * attributes
    * itemの要素
    * name/value型、JSON型などアイテム感で不揃いであっても問題ない
    * 型
      * String.Number/Binary/Boolean/Null/多値（Set）データ/ドキュメントデータ（List/Map）
    * Partation、Sortに該当するAttibutes意外は事前定義不要
  * Partation Table
    * Partation Keyは単体でプライマリキーとして利用できる
    * 順序は指定しないハッシュインデックスを構築するためのキー
    * テーブルは、性能を確保するために分割（パーティショニング）される場合がある
  * Partation Sort Table
    * PartitionとSortでプライマリキーとすることもできる
    * 同一のPartation Keyでのデータの並びを保証するためにSortKeyが使われる
    * Partation Keyの数に上限はない
      * Local Sencondary Indexesを使用するときはデータサイズ上限あり


* Scaling
  * スループット
    * テーブル単位で読み書きのスループットを指定する
  * サイズ
    * テーブルには任意の数のアイテムが追加可能
    * 1つのアイテムの合計サイズは400KB
    * local sencondary indexについて、異なるハッシュキーの値ごとに最大10GBのデータを格納
  * テーブルレベル
    * テーブルレベルによってプロビジョニングする
    * 読み込みと書き込みのキャパシティユニットは個別に設定
      * キャパシティは大きめに設定しておき、実運用で様子を見て調整する
    * Read Capacity Units（RCU）
      * 1秒あたりの読み込み項目数×項目のサイズ（4KB）
      * 結果整合性のある読み込みをする場合はスループットが2倍
        * 例1：アイテムサイズが1.2KBのときは、サイズは1.2/4=0.3で、切り上げて1となる-> 読み込み項目数は1000回/秒となる
        * 例2：アイテムサイズが4.5KBのときは、サイズは4.5/4=1.125で、切り上げて2となる-> 読み込み項目数は2000回/秒となる（ただし、結果整合性のある読みこの場合は1/2の1000RCU））
    * Write Capacity Units（WCU）
      * 1秒あたりの書き込み項目数×項目のサイズ（1KB）
      * 1KBを下回る場合は繰り上げられて計算
        * 例1：アイテムサイズが512Bのときは、0.512/1≒0.5で、切り上げて1となる右書き込み項目数は1000項目/秒 1000WCU
        * 例2：アイテムサイズが2.5KBのときは、2.5/1=2.5で、切り上げて2となる右書き込み項目数は3000項目/秒 3000WCU
  * パーティション
    * DynamoDBがマネージ
      * ユーザーはパーティション数を気にしなくていいが、逆に言うと直接しる方法もない。
    * パーティショニング分割の特性
      * プロビジョンされたスループットを確保するためにテーブルを複数のパーティションに分散して格納
      * Partation Keyをパーティション感でのデータ分散に利用し、格納ストレージサイズやプロビジョンされたスループットによって自動的にパーティショニングを実施
    * パーティション内でのスループット
      * スループットはパーティションに均等に付与される
        * プロビジョンしたスループットは各パーティションに均等に付与されて、全体でキャパシティユニットの合計値の性能が出るように設計されている
        * アクセスされるキーに偏りが発生すると思うように性能が出ない事態を招いてしまう
    * パーティション数
      * ストレージ容量とスループットで決まる
        * 1つのパーティションに対して最大3000個の読み込みキャパシティーユニット、または1000個の書き込みキャパシティユニットを割り当てられる
          * スループットに対するパーティション数は、RCU/3000 + WCU/1000
        * 単一のパーティションには約10GBのデータを保持される
          * サイズに対するパーティション数は、テーブルサイズ（GB）/10GB
        * スループットに対するパーティション数とサイズに対するパーティション数の大きいほうがパーティション数になる
    * Burst Capacity
      * DynamoDBはパーティションごとのキャパシティのうち、利用されなかった分を過去300秒分までリザーブ
      * プロビジョン分を超えたバーストトラフィックを処理するために利用する
  * Local Secondary Index（LSI）
    * Sort Key以外に絞り込み検索を行うkeyを持つことができる
    * Partition Keyが同一で他のアイテムからの検索のために利用
    * すべての要素（テーブルとインデックス）の合計サイズを、各ハッシュキーごとに10GBに制限
      * 元データは同じだが、Partation Keyは同じでSort Keyが違うテーブルを持てる
        * 両方のテーブルを使うことでより細かい条件で検索できる
  * Global Secondary Index（GSI）
    * Partation Key属性の代わりとなる
    * Partation Keyをまたいで検索を行うためのインデックス
    * GSIはテーブルとは独立したスループットをプロビジョンして利用するため、Tableの更新とは非同期更新
  * LSI/GSIの注意点
    * スループットやストレージ容量を追加で必要
    * 特にインデックスの数が増えれば増えるほど書き込みコストが上がる
    * セカンダリインデックスに強く依存するようなテーブル設計であれば、一度RDBで要件を満たせないかを確認してみるのがベター

#### Amazon DynamoDB TTL

* TTL:Time To Live
  * テーブルの項目の有効期限が切れ、データベースから自動的に削除できるタイミングを定義できる
  * プロビジョニングされたスループットを使用することなく、関連性のないデータのストレージ使用量と保存コストを減らせる
  * 追加料金無しで提供
  * 既存・新規のテーブルに設定可能
  * DynamoDB Streamsとの併用可能
* TTLの注意点
  * 期限切れになっても即削除・読み取りできなくなるわけではない
  * 最大48時間削除までかかる
  * 読み取り時に期限切れのものを取得しないようにするにはQueryを利用するかアプリ側でフィルタ処理が必要

#### Amazon DynamoDB AutoScaling

* フルマネージドでWCU、RCU、GSIに対する設定を管理
* 設定はターゲット使用率と上限、下限を設定するだけ
* マネージメント今ソース、CLI、SDKでの操作が可能
* 利点
  * RCU、WCUの設定のための推測が不要になる
  * アプリケーションからのリクエスト数に応じて自動的に容量拡大
  * リクエストが減ったときに自動的に容量を縮小
  * マネージメントコンソールから可視化された状態で管理が可能

#### Amazon DynamoDB Accelerator（DAX）

* DynamoDBの前におくもの（キャッシュ用？）
* フルマネージドかつ高可用性
* DynamoDB API五感
* Read：読み込みのとき（例GetItemを呼んだ）にキャッシュがなければDynamoDBから直接リードして、DAXのキャッシュにいれてItemを返す
  * キャッシュヒットしたときはキャッシュのItemを返す
* Write-through：書き込みがあったときはDynamoDBに書き込んでキャッシュをDAXにいれて、Itemを返す
* Scalable：最大10ノードまでスケールアウト対応
  * Scale-upも可能
* ユースケース
  * 予期せぬ急激なアクセスがある場合
  * マイクロセカンド単位でレスポンスを早めたい場合
* 価格
  * 使用時間に応じて課金
  * インスタンスタイプによって単位時間あたりの価格は異なる

#### Amazon DynamoDB Streams

* DynamoDBに行われた追加・更新・削除の変更履歴を保持し、取り出し可能
* 過去24時間以内にそのテーブルのデータに対して行われた変更のストリーム全てアクセス可能
* 24時間経過したストリームデータはその後消去される
* DynamoDB Streamsの容量は自動的に管理
* DynamoDB Streamsからの読み取り
  * DynamoDB SDK、CLIやKCL（Kinesis Client Library）を用いて読み取り可能
  * DynamoDBテーブルのWriteプロビジョニングスループットの最大2倍の速度で、DynamoDB Streamsから更新を読み取ることが可能
    * DynamoDBテーブルにプロビジョニングを十分にしていることが必要
    * 1秒間に1000項目を更新するのに充分な能力をプロビジョニングしていたら1秒間に最大2000件の更新をDynamoDB Streamsから読み取ることができる
  * DynamoDBへの変更は1秒未満で反映される
* DynamoDB Streamsのユースケース
  * クロスリージョンレプリケーション
  * ゲームやソーシャルサイトなどのユーザーの集計、分析、解析のための非同期集計
  * ユーザーが新しい写真をアップロードするとすぐにサークル内のすべての友人のモバイルデバイスに自動的に通知するモバイルアプリケーションの構築など
* DynamoDB Streams API
  * ListStreams
    * 現在のアカウントのエンドポイントのストリーム記述子（ストリームARN）のリストを返す
  * DescribeStream
    * 指定されたストリームの詳細情報を返す
    * ストリームの現在の状態アマゾンリソース名（ARN）、そのシャードの構成
  * GetShardIterator
    * シャードイテレータの位置を返す
    * シャードのどこからデータを読み始めた以下を指定するために指定する
  * GetRecords
    * 指定されたシャード内からのストリームレコードを返す
    * GetShardIteratorから取得したシャードイテレータを指定する
    * 1回で最大1MBまたは1000県のストリームレコードを取得可能
* 利用料金
  * Streamsの機能を有効化するのは無料
  * 毎月最初のReadリクエスト250万件は無料
  * その後は0.0228USD/10万
* Amazon Kinesisとの連携
  * Kinesis APIを使い慣れている開発者がDynamoDB Streamsを簡単に利用可能にするライブラリ：KCL（Kinesis Client Library）
  * StreamからAmazon Kinesis Client Library Applicationにデータを流せるようにでいる

#### Amazon DynamoDB Trigers

* DynamoDBとAWS Lambdaを組み合わせて使えるようにする仕組み
* ユースケース
  * DynamoDBへの書き込みに応じて値チェックをしつつ別テーブルの更新やプッシュ通知を実行
  * DynamoDBの更新状況の監査ログをS3に保存
  * ゲームデータなどのランキング集計を非同期に実施
* 料金
  * AWS Lambda関数に対するリクエスト回数と実行時間の分のみ支払い
  * AWS Lambda関数がテーブルに関連付けられたストリームに対して行う読み込みについては課金されない

#### 2-Tierアーキテクチャ

* 仮想サーバー（EC2）を利用せずにクライアントから直接AWSのサービスを利用するアーキテクチャのこと
* 例
  * モバイルアプリからAmazon Cognitoで認証
  * モバイルアプリがDynamoDBにデータ保存
    * 保存されたデータに対してはAWS Lambdaが処理
  * Amazon SNS Mobile Push でプッシュ通知

### Amazon EC2（Elastic Compute Cloud）

#### Amazon EC2とは

* 数分で移動して、1時間または秒単位の重量柿傳利用可能なAWSクラウド上の仮想サーバー
* サーバーの追加・削除・マシンスペック変更も数分で可能
* 管理者権限（root/Administrator）で利用可能
* 20の地理的リージョンにある61のアベイラビリティーゾーン（AZ）で運用
* EC2は任意のリージョンならびにアベイラビリティーゾーンを選択して起動することができる
  * ただしリージョンによって選択できるインスタンスの種類は一部異なる
* [Amazon VPC（Virtual Private Cloud）](#amazon-vpc（virtual-private-cloud）)によりクラウド内に独立したプライベートネットワーク空間を構築
* AWSをと既存環境のハイブリッド構成も実現可能
* 既存のOS/ミドルウェアが利用可能
* API経由で構築可能
#### EC2で利用できるプロセッサーとアーキテクチャ

* intel Xeon Processor（x86-64 arch）
* AMD EPYC Processor（x86-64 arch）
  * intelと比較して10％コスト低減
* AWS Gravion Processor（64-bit Arm arch）
  * intelと比較して最大45％コスト低減

#### EC2に関連する主要コンポーネント

* Amazon Machine Image(AMI)
* Amazon CloudWatch
* Auto Scaling
* Application Load Balancer
* [Key Pairs](#key-pairs)
* Security Groups
* [Amazon VPC（Virtual Private Cloud）](#amazon-vpc（virtual-private-cloud）)
* Amazon Elastic Storage（EBS）
* AWS Management Console

#### EC2インスタンスタイプ

* ネーミングポリシー：{インスタンスファミリー}{インスタンス世代}{（追加機能）}.{インスタンスサイズ}
  * 例：c5d.xlarge
* メモリ・I/O、CPUクロック重視、GPU・FPGA搭載、価格重視など特徴に持ったインスタンスファミリーを提供
* インスタンス世代
  * 同じインスタンスファミリーでも盛大が進むにつれ数字が大きくなる。
  * 世代が新しい方は高性能でコストパフォーマンスも高いため、極力最新世代のインスタンス利用が推奨

#### EC2インスタンス追加機能のオプション表記

* d:内蔵ストレージ付加
* n:ネットワークを強化
* a:AMDのCPUを搭載
* その他（従来よりCPU、メモリ搭載量が異なる etc...）

#### EC2インスタンスサイズ

* CPU、メモリ、ネットワークのキャパシティによってインスタンスサイズが分類されている
  * ネットワークとはNW帯域幅
  * EBS帯域幅もインスタンスサイズによって異なる
* 汎用インスタンスの使い分け
  * T3 Instances 時々高いCPU使用率を必要とする多くのワークロード
    * T3 は負荷に応じて高いレベルまでCPU性能がバーストする機能を持っているため。
  * M5/M5a Instances CPU、メモリおよびネットワークリソースそれぞれをバランス良く使用するワークロード
  * A1 Instances 複数のCPUコアを複数インスタンスにまたがってスケールアウトし、広範なARMエコシステムによってサポートされるワークロード
    * ARM NeoverseコアのCPU AWS Gravitonプロセッサを搭載
    * ほかファミリと比較して最大45%のコスト削減を期待できる

#### EC2の通信とセキュリティ

##### Key Pairs

* EC2インスタンス上のOSに対する安全な認証を提供する機能
  * 鍵認証
  * AWSでは公開鍵のみ保持し、起動時に公開鍵をコピーする
  * 秘密鍵はユーザーにて適切に管理保管する

##### Security Group

EC2インスタンへのトラフィックを制限するファイアウォール機能

* デフォルトでは全トラフィックが閉じた状態
* 必要な受信アクセスに対してアクセスルールを定義する
  * プロトコル（TCP/UDP）
  * 宛先ポート
  * アクセス元IP/Security Group
* ルールをひとまとめにしたテンプレートをSecurity Groupと呼ぶ

##### AWS上でのIPの種類

* Private IP
  * 必ず割り当てられるIPアドレス
  * EC2作成時にIPを指定可能（VPCのみ）
  * Stop/StartしてもIPは変わらず固定（VPCのみ）
* Public IP
  * ランダムに割り当てられるPublicIP
  * Stop/Startすると別のIPが割り当てられる
  * 割当の有無を変更することも可能（VPCのみ）
* Elastic IP （EIP）
  * 別インスタンへ再マップも可能な静的Public IP
  * Stop/StartしてもIPは変わらず固定（VPCのみ）
  * 利用していない場合は課金発生

##### Elastic Network Interfaces（ENI）

* VPC上で実現する仮装ネットワークインタフェース
* 以下をENIに紐づけて維持可能
  * Private IP
  * Elastic IP
  * MACアドレス
  * セキュリティグループ
* インスタンスによって割当可能な数が異なる

##### EC2インスタンスのネットワーク帯域について

* EC2間のトラフィックには下記の制限がある
  * シングルフロー通信：最大5Gbpsまたは10Gbps（同一Cluster Placement Groupの場合）
  * マルチフロー通信：各インスタンスタイプがもつ通信帯域の最大
    * 例えばc5n.18xlargeであれば最大100Gbps
* EC2で5Gbps以上の帯域幅を実現するためには、通信の多重化とマルチコアへの分散を意識する必要がある

#### EC2のストレージ

##### EC2インスタンスストア

* ホストコンピュータに内蔵されたディスク
* EC2インスタンスと不可分
* EC2インスタンスをStop/Terminateするとクリアされる
* 性能・容量はインスタンスタイプごとに規定
* 追加費用無し

##### Amazon Elastic Block Store（EBS）

* ネットワークで接続
* EC2インスタンスとは独立管理
* EC2インスタンスをStop/TerminateしてもEBSは保持可能
* Volumeごとに性能・容量を定義可能
* EBSの費用が別途発生
* Snapshotを取得しS3に保存可能

##### EBS最適化オプション

* 通常のネットワークとは別にEBS専用帯域を確保するオプション
* 起動時に有効/無効
* 帯域はインスタンスサイズによって異なる
* インスタンスタイプによってはデフォルトで有効

#### AMI（Amazon Machine Image）とは

* AMIはインスタンス起動に必要なOSTイメージ
  * イメージは内部的にS3に保存
* AWS以外にサードパーティもAMIを提供
* 自由に自前のカスタムAMIを作成可能
  * 作成したAMIは別アカウントと共有可能
* カスタムAMIから何代でもEC2インスタンスを起動可能
* 別リージョンへのコピーも可能

##### AMIの分類

* アーキテクチャ
  * x86/Arm
* ビット数
  * 32bit
  * 64bit
* 仮想化方式
  * 準仮想化（Paravirtual：PV）米古い形式のため、非推奨
  * 完全仮想化（Hardware-assisted VM：HVM）
* ブートストレージ
  * EBS Backed
  * Instance Store-Backed（S3 Backed）
* 一般的な推奨は64bit HVM EBS-Backed

##### AMIを探す

* コミュニティAMI
  * コンソールでEC2作成の画面で検索
  * CLI/APIでdescrive-imagesを利用
* AWS Marketplace
  * AWS上で実行されるソフトウェアやサービスを見つけて購入しすぐに使用開始できるオンラインソフトウェアストア
  * 多くのソフトウェアベンダー製品やOSSのソフトウェアがインストール済みOSイメージを公開中
  * 優勝ソフトウェアを従量課金で利用可能

##### その他

* 最新世代インスタンス（Nitro Hypervisor）の注意事項
  * Nitro Hypervisorで実行されるインスタンスはC5,M5R5Z1dT3,A1,P3dn, ハイメモリ
  * ENA, NVMeの機能要件を満たしているか確認するスクリプトは公開中
  * AmazonならびにUbutu、Windows Server、CentOSなどの各キュミニチュが配布する最新のAMIはNitro Hypervisorをサポート済み
* 物理ホストの専有オプションあり
* プレイスメントグループオプション
  * EC2インスタンスの物理的な配置戦略オプション
    * Cluster
      * EC2インスタンスを密な場所に配置、ネットワークパフォーマンスを最適化
      * 広帯域（Full Bisection）で低廉手死活こうPPS（packets per seconds）なインスタンス間通信を実現
      * 単一アベイラビリティゾーンに閉じる
      * 複数のプレイスメントグループにはぞくせない
    * Spread
      * EC2インスタンスを別々のハードウェアに分散配置し、物理サーバ障害時に複数のインスタンスが同地に影響を受ける確率を軽減
      * 同一AZにHAクラスタ（High Availabilityクラスタ：冗長化して可用性を高めるようにすること）を展開している際などに有益
      * AZをまたいで定義することが可能で、１AZあたり実行中のインスタンスは最大7つ
  * Partition Placement Group：EC2ハードウェア障害の影響を最小化するための新しいPlacement Groupオプション
* CPU最適化オプション：インスタンス起動時にCPUコア数、ハイパースレッディングの無効化をして可能とするオプション
* EC2にアタッチして利用するアクセラレーションオプション
  * 特定ワークロードを高速化できるローコーストに利用可能なアクセラレーター
  * Elastic Graphics：EC2インスタンスにグラフィックスアクセラレーション機能をかんたんに追加
  * Elastic Inference：必要なvCPU/メモリを備えたEC2インスタンスにアタッチすることで推論処理を高速化するサービス

#### EC2の運用管理

##### EC2のライフサイクル

* 起動したインスタンスは状態を持つ
  * Running
    * 実行中。課金される
    * StopそうさでStoppedへ、Terminate操作でTerminatedに遷移
  * Stopped
    * 停止中。課金されない
    * Start操作で再度Running状態に遷移
  * Terminated
    * 削除済み。Stop/Startはできない
  * Stopped（Hibernate）
    * メモリ状態をディスクに書き出した上でインスタンスを停止
    * 課金はEBSボリュームとアタッチされたEIPの料金だけで停止状態と同じく、時間当たりのインスタンス料金は発生しない。
    * メモリサイズやEBS速度に応じて停止・再開が可能

##### Amazon CloudWatchによるモニタリング

* AWSサービスのメトリックス監視
  * メトリックス：CPU使用率などの監視項目
  * メトリックスは予め定義され、構成済み
* 各メトリックスに対してアラームを作成可能
  * しきい値を設定（例：CPU使用率60%以上）
  * メトリックス値がしきい値を超えたら起こすアクションを定義（例：メールで通知）
* EC2のログ監視 Amazon CloudWatch Logs
  * メトリックスとアラームも作成可能

##### スケジュールイベント


* リタイア
  * インスタンスをホストしているハードウェアで回復不可能な障害が検出された場合、インスタンスリタイヤが予定される
  * スケジュールされたインスタンスには時計マークが表示される
  * EC2のEventsメニューで一覧表示
  * DescribeInstanceStatus APIで取得可能
* 取るべきアクション
  * リタイア日までにStop->Startを実行


##### AutoRecovery

* インスタンスの異常を検知して復旧
  * インスタンスの異常を2つにわけて検知
    * StatusCheckFaild_System: インスタンスをホストしているハードウェア側の障害
    * StatusCheckFaild_Instance: EC2インスタンス内部で障害が発生している
  * CloudWatchアラームにて「RecoverThisInstance」アクションを設定
  * アラーム発生時に自動的にEC2インスタンスが再起動される
    * IPアドレス、インスタンスIDは維持される

##### 自動化ツールと機能

* インフラの自動化を支援する機能やサービス群
  * User-data
    * 起動時にスクリプト実行を行う
    * AMIでカバーできない起動時の設定変更に使う
  * Launch Templates
    * EC2起動時に設定すべき項目をテンプレート化する
    * 社内標準の設定の適用やベストプラクティスに従ったインスタンスの起動をしたいときに使える
  * Instance Meta Data
    * 自インスタンスに関わるデータを取得することができる
    * User-dataも取得可能
      * インスタンスタイプに応じて設定ファイルのメモリ量を設定するとか
      * リージョンに応じてタイムゾーンを設定するとか
      * ネットワーク情報を取得してDNSに自動登録
  * EC2 Fleet
    * 1回のリクエストで大量のインスタンスを起動させられる
    * EC2 Fleet自体の利用料は無料。起動したインスタンス分は課金される
  * その他AWSの機能やサービス群
  * サードパーティ製のもの

##### EC2の費用

* EC2で起動の料金は他のサービス（VPSやEBS、S3）に比べると高い
* 購入オプションがある
  * オンデマンドインスタンス
  * リザーブドインスタンス
  * 1年間または3年間、常に利用可能なキャパシティ予約で最大75%割引
  * スケジュールされたリザーブドインスタンスもある
    * 日次、週次、月次で指定した時間帯のみのキャパシティ予約によって、5%~10%割引
      * `memo` 開発用のインスタンスってこれでいいのでは？
  * スポットインスタンス
    * 未使用キャパシティを時価で購入。最大90%OFF
  * 専用ホスト（Dedicated Hosts）
    * インスタンス実行用の物理ホストの単位で支払い
  * ハードウェア専有インスタンス（Dedicated Instance）
    * シングルテナント
      * `memo` 俗に言うAWSガチャ回避に使えるものかな
* 課金は1秒単位（秒課金）
  * 表記は1時間単位のまま
  * 最小請求期間は1分（1秒使ったら1分間分の請求は最低来るということ）
* OSやソフトウェアの料金
  * 商用OSでも構成によってはライセンス持ち込みも可能で秒課金に対応している
  * 商用ソフトウェアもソフトウェア・ライセンス持ち込みもできる
* 課金の管理
  * コスト管理
    * 利用料管理
      * 請求書
      * Detailed Billing Reporter
      * Cost Explorer
  * 利用管理
    * 傾向分析
      * Cost Exploler AWSリソースの使用量を時系列でグラフ化するツール
    * 過剰利用対策・コスト最適化
      * 予算
      * Trusted Advisor 推奨事項を教えてくれる
  * 見積もり
    * Simple Monthly Calculator

### Amazon ECR（Elastic Container Registry）

### Amazon ECS（Elastic Container Service）

### Amazon EFS

### Amazon ElasticCache※

### Amazon Fargate

### Amazon Glacier

### Amazon Kinesis

### Amazon RDS

### Amazon Route53

### Amazon Simple Storage Service（S3）

[資料](https://www.slideshare.net/AmazonWebServicesJapan/20190220-aws-black-belt-online-seminar-amazon-s3-glacier)

#### Amazon S3とは

* 特徴
  * 安全
  * 容量制限なし
    * 1ファイル最大5TB
      * `memo` 容量制限はないけど、制約はあるということか
  * 高い耐久性
    * 99.999999999%
  * 低コスト
    * 月額1GB/約3円
  * オブジェクトストレージ
    * オブジェクトそれに付随するメタデータ、そのオブジェクトにアクセスするためのユニークなIDで構成されるデータの倉庫
    * keyをもとにhttp/httpsでアクセス
* 利用シーン
  * データストアから過去のデータを退避
  * 別のデータストアにロード
  * クライアントから直接PUT/GETする
* 用語
### Amazon S3 Glacier

* 安全性とコスト効率を重視したアーカイブ向けストレージ
* S3のデータをアーカイブする

### Amazon SES※

### Amazon SNS（Simple Notification Service）※

### Amazon SQS※

### Amazon VPC（Virtual Private Cloud）

* AWS上にプライベートネットワーク空間を構築
  * 任意のIPアドレスレンジ利用可能
* 論理的なネットワーク分離可能
  * 必要に応じてネットワーク同士を接続することも可能
* ネットワーク環境のコントロール可能
  * ルートテーブルや各種ゲートウェイ、各種コンポーネント
* 複数のコネクティビティオプション選択可能
  * インターネット経由
  * VPN/専用線（Direct Connect）

#### VPCのコンポーネント

* 全体のネットワーク空間：VPCとして定義する
  * 例：10.0.0.0/16
* パブリックサブネット：サブネットを使用する
  * 例：10.0.1.0/24
* インターネットへの接続を設定：VPCにルートテーブルとインターネットゲートウェイを使用する
* プライベートサブネット：サブネットを使用する。ルートテーブルも使用する。
  * 例：10.0.2.0/24
* パブリックサブネットからインターネットへ接続できるように設定：パブリックサブネットにNAT（Network Address Translation：プライベートアドレス→グローバルIPに変換）ゲートウェイを設置
* ※インターネットに接続しないネットワークも作成可能
* オンプレミスとの接続：VPCにバーチャルプライベートゲートウェイを設置、接続先に仮想ルータ、VPNコネクションか専用線でつなぐ

##### インターネット接続VPCのステップ

* アドレスレンジを選択。VPCエンドポイントとプライベートリンク？
  * VPCに設定するアドレスはすでに使っている、もしくは使うであろうネットワークアドレスをさける
  * 最初に作成したアドレスブロックは作成あとで変更ができないので注意。2個目以降は追加・削除ができる。
* AvailabilityZoneにおけるSubnetを選択
  * 推奨：各AZにSubnetを設定
  * 推奨：Subnetに24設定
* インターネットへの経路を設定。仮想ルータとインターネットゲートウェイで。
  * ルートテーブルはパケットがどこに向かえば良いかを示すもの
  * VPC作成時にデフォルトで1つルートテーブルが作成される
  * VPC内は作成時に指定したCIDRアドレスでルーティングされる
  * インターネットゲートウェイを作成してVPCにアタッチすると、VPCからインターネットに接続可能に
* VPCへのIn/Outトラフィックを許可
  * セキュリティにはセキュリティグループとNetwork ACLs
  * セキュリティグループ：ステートフルFirewall
    * サーバー単位で設定する
    * AllowのみをIN・OUTで設定する（ホワイトリスト型）
    * デフォルトでは同じセキュリティグループ内の通信しか許可されない（外からの通信は禁止）
    * インスタンス管理者がセキュリティグループを適用すればその管理下になる
    * すべてのルールを適用する
    * WEB公開するにはインターネット（0.0.0.0/0）から80ポートを許可する
  * ACLs：ステートレスFirewall
    * サブネット単位で設定する
    * サブネット内のすべてのインスタンスがACLの管理下に入る
    * Allow/DenyをIN・OUTで設定する（ブラックリスト型）
    * 番号の順序どおりに適用される
    * デフォルトではすべての送信元IPを許可

##### アベイラビリティゾーン

AZは1つ以上のデータセンターで構成される

* 1リージョン内にAZが複数存在
* AZはお互いに地理的・電源的・ネットワーク的に分離
* 2つのAZを利用した冗長構成を容易に構築
* リージョン間のAZ間は高速専用線で接続（リージョン間も可能な限り高速専用線で接続）

##### Ingress Routing

* Internet Gateway/VGW（仮想プライベートゲートウェイ）に対するアウトバウンド・インバウンド双方のトラフィックを特定インスタンスEC2インスタンスのENI(Elastic Network Interface)にむけることができる。
* VPCに出入りする全トラフィックが特定EC2インスタンスを通過することを強制するため、IDS/IPSやFirewallによる監視・通信制御を効果的に実行可能
* Ingress Routingはすべてのリージョンで使用可能
* Internet Gateway/VGW用のルーティングテーブルを作成して、それをInternet Gateway/VGWにアタッチする
* サブネットに関連付けたルーティングテーブルやVPC作成時のルーティングテーブルはIngress Routingに紐付けできない
* ENIをターゲットにするのでAZ/インスタンス障害時にlamdbaなどでルーティングテーブルを切り替える仕組みが必要（AWS Transit Gatewayのインライン監査と同じ）
* Ingress Routingを使うのならば、他のサブネットのIGW/VGW向けのルーティングは指定したENIに向ける
* 指定できるCIDRはすでに作成されているサブネットと完全一致が必要


##### サブネット内のDHCP

* サブネット内のENI（Elastic Network Interface）にはIPが自動に割り当てられる
* プライベートIPを固定した場合はDHCPで該当のIPが割り当てられる
* EC2インスタンスを再起動しても割り当てられた固定IPは変わらない
  * メモ 停止しているインスタンスのIPアドレスと被っているインスタンスをたてるとめんどうなことになりそう


##### Route53 resolver（AmazonProvidedDNS）

* Amazonが提供するDNSサービス
* Route53 Resolverは以下の2つのアドレスが利用可能
  * VPCのネットワーク範囲（CIDR）のアドレスに+2をプラスしたIP（10.0.0.0/16の場合は10.0.0.2）
  * 169.254.169.253
* VPC内のEC2インスタンスからのみ参照可能（VPNや専用線経由では参照できない）
  * Route53 Resolver for Hybridsで解決
* Route53 Resolver for Hybrids
  * オンプレミスからDirect Connect/VPN経由によるVPC Provided DNSへの直接アクセス可能なDNSエンドポイントを提供
  * 逆方向（VPC内からオンプレミスへの特定ドメイン参照）も可能
  * 複数AZにまたがったエンドポイント設定による冗長性をもたせることも可能

##### DNS機能の有効化とホストへのDNS名割当て

* Enable DNS resolution
  * 基本はyesとする
  * NoにするとVPCのDNS機能が無効となる
* Enable DNS hostname
  * YesするとDNS名画割り当てられる
  * Enable　DNS　resolutionをtrueにしないと有効にならない

##### Amazon Time Sync Service

* VPC内で稼働するすべてのインスタンスからNTPで利用できる高精度な時刻同期サービス
* EC2インスタンス内でNTPサーバのIPアドレスとして、169.254.169.123を設定するだけで利用できる
  * このアドレスはリンクローカルアドレスなので、プリベートサブネット内でも利用できる。外部インターネットへのアクセスは不要
* うるう秒への対策実装済み
* 無料で全リージョンで利用可能

##### IPv6の対応

* Site to Site VPNでIPv6対応している
* Egress-only Gateway(EGW)を利用してIPv6においてもプライベート利用が可能

#### オンプレミスとのハイブリッド構成

##### VPCとのプライベートネットワーク接続

* VPN接続
  * バーチャルプライベートゲートウェイを利用したサイト間VPN（Site to Site VPN）
  * 1つのVPN接続は2つのIPSecトンネルで冗長化
  * ルーティングは選択可能
    * 静的（スタティック）
    * 動的（ダイナミック：BGP）
      * BGP（Border Gateway Protocol）
        * インターネットのパケットの宛先を正確に把握し、維持していくための技術である経路制御の1つ
        * インターネット上の組織間の経路情報をやり取りする
        * 参考：[インターネット10分講座：BGP](https://www.nic.ad.jp/ja/newsletter/No35/0800.html)
  * エンドポイントを利用したClient VPN
    * OpenVPNベースでのクライアントVPN接続を提供するマネージドサービス
    * どこからでもAWS・オンプレミス上リソースへの安全なアクセスを提供
* 専用線接続
  * AWS Direct Connectを利用し、一貫性のあるネットワーク接続を実現
    * AWSとお客様設備を専用線でネットワーク接続
  * 本番サービス向け
    * 帯域はポートあたり1G/10Gbps/LAG可能
    * 品質はキャリアによって高い品質が保証されている
    * 障害時の切り分けも容易
      * エンドツーエンドでどの経路を利用しているか把握できているため
    * ただし、キャリアの専用線サービスの契約が必要で、構築のリードタイムも数週間かかる

##### Direct Connect Gateway

* Direct Connect GatewayがHubになり、同一アカウントに所属する複数のリージョンの複数のロケーションから複数リージョンの複数のVPCに接続できる機能
* 1つ以上のDirect Connectロケーションに繋げば全世界の全リージョン（中国除く）に閉域網接続でき、同一リージョンまたは世界の複数リージョンをまたいで複数のVPCに接続できる

##### VPNとDirect Connectの冗長化

VPNとDirect Connectを同じVGWに接続することが可能

* Direct Connect＝アクティブ
* VPN＝スタンバイ


VPCから見たOutboundは必ずDirect Connectが優先される

##### AWS Transit Gateway

* VPCとオンプレミス間の相互接続を簡単にするためのサービス
* Multicast
  * データストリームを仮想的に複数のアプリケーションに配信することが可能になる
  * 株価配信やマルチメディアコンテンツ配信など、データを購読者にストリームする際に最適
  * 全てではないがバージニア、フランクフルト、サンパウロ、バーレーン、香港、ソウルリージョンで利用可能
  * 本番、テスト、開発環境に配信もできるよう

#### VPCの設計

* CIDRは既存のVPC、社内のDCやオフィスとかぶらないアドレス帯をアサインする
  * プライベートアドレスでない場合は100.64.0.0./10 CGNAT（Carrier-GradeNAT：ISPなどが自社ネットワークと他社ネットワークの分解点付近でネットワークアドレス変換を行うこと）
* 複数のアベイラビリティゾーンを利用し、可用性の高いシステムを構築
* パブリック/プライベートサブネットへのリソースの配置を慎重に検討
* 適切なセキュリティ対策を適用する
* システムの境界を明らかにし、VPCのをどのように分割するか将来を見据えてしっかりと検討する
  * インフラはこういうのはなかなか簡単に変更とはいかないからだろうか？

##### AWSクラウドとVPC

* VPC内と外のどちらにリソースやエンドポイントが存在するかサービスによって異なる
* VPCからAWSクラウドへのリソースはIGW経由の通信となる
  * プライベートサブネットからはNATゲートウェイ
  * S3であればVPCからエンドポイントの利用も可能
  * パブリックサブネットからは自動割当またはEIPのパブリックIPから直接アクセス
    * 意識しておかないと無駄な経路を踏むように実装してしまいそう
  * S3, DynamoDBへのアクセスはVPCからエンドポイント（Gateway型）が利用可能

##### VPC Endpoint概要

* Gateway型のアクセス
  * VPC Endpointは、グローバルIPをもつAWSサービスに対して、VPCの内部から直接アクセスするための出口
  * サブネットに特殊なルーティングを設定し、VPC内部から直接サービスと通信する（例、VPC内からS3にアクセスするときは、Amazon   Provided DNSからS3のIPアドレスを引いて通信するときにVPC Endpointを経由しろと変換されて、S3にアクセスする
  * 通信先のIPアドレスはグローバルIPアドレス
  * アクセス制御はエンドポイントポリシー：IAM Policyと同じ構文でアクセス先のリソースを制限可能
  * 利用料金は無料
  * 冗長性はユーザーで意識する必要はない
* PrivateLink（Interface型）の動作
  * サブネットにエンドポイント用のプライベートIPアドレスが生成される
  * VPC内部のDNSがエンドポイント向けの名前解決に対してプライベートIPアドレスで回答する
  * エンドポイント用プライベートIPアドレス向け通信が内部的にサービスに届けられる
    * エンドポイント用IPアドレスはサービスごとに設定が必要で、IPアドレスは自動で採番される
    * アクセス制御はセキュリティグループでアクセス元IP、ポートを制御可能。対象のサービスの特定のリソースへのアクセスは制御不可
    * 利用料金は有料で、サービスごとに1プライベートIPごとに課金
    * 冗長性を持たせるにはマルチAZで配置する
  * オンプレミスにネイティブで対応

##### NATゲートウェイ

* AWSによるマネージドNATサービス
* プライベートサブネットのリソースがインターネットまたはAWSクラウドへ通信するために必要
* EIPを割り当て
* 高パフォーマンス
* アベイラビリティーゾーンごとに設定するのがベストプラクティス

##### VPCの接続バリエーション

* VPC Peering
  * VPC間は1:1
  * 100VPCまでの制限あり
* AWS PrivateLink
  * VPC間は1:N
  * スケーラブル
  * NLBとエンドポイントの費用がかかる
  * Scopeはアプリケーション共用
* AWS Transit Gateway
  * VPC間は1:1でも1:NでもOK
  * スケーラブル
  * AZごとに費用がかかる
  * Scopeはネットワーク共用
* その他
  * アカウントをまたいだVPCの共有？ができるVPCシェアリング
    * VPC数削減にきくらしいけど、今わたしはまだよくわからない。。。

##### VPCの設定方法

* AWSが提供
  * マネージメントコンソール
  * AWS CLI/AWS SDK
  * AWS CloudFormation
    * JSON/YAMLテンプレートをもとにAWS環境を構築
    * AWS CloudFormationデザイナー
      * GUIでテンプレートの作成が可能
* サードパーティツール
  * ansible
  * terraform


#### VPCの運用

* VPC Flow Logs
  * ネットワークトラフィックをキャプチャし、CloudWatch Logs、S3へPublishする機能
  * ネットワークインタフェースを送信元/送信先とするトラフィックが対象
  * セキュリティグループとネットワークACLのルールでacepted/rejectされたトラフィックログを取得
  * キャプチャウインドウと言われる時間枠（約10分間）で収集、プロセッシング、保存
  * RDS、Redshift、ElasticCache、WorkSpacesのネットワークインタフェーストラフィックも取得可能
  * 追加料金はなし（CloudWatch Logs、S3の標準料金は課金）
* VPC Traffic Mirroring
  * EC2インスタンスのENIからネットワークトラフィックをミラーリングする機能
  * ネットワークトラフィックのIN/OUTをコピー（ミラー）し、VXLANでカプセル化して宛先に送信
  * ユースケース
    * 脅威検出（フォレンジック）
    * コンテンツモニタリング
    * 問題判別
  * VPC Flow Logsには含まれない、パケット内容の取得が可能
  * 設定要素（リソース）
    * ソース
      * VPC Traffic Mirroringミラーを有効化するENI
      * Mirrorセッションが参照する
    * フィルタ：
      * ミラーする対象のパケットを取得して、ターゲットに送る
      * Mirrorセッションが参照する
    * ターゲット：
      * ミラーされたパケットを受け取る
      * Mirrorセッションが参照する
    * セッション：
      * ソース、フィルタ、ターゲットを管理
* Amazon GuardDutyによる脅威の検知と通知
  * 脅威
    * 悪意のあるスキャン
    * インスタンスへの脅威
    * アカウントへの脅威
  * Amazon GuardDutyが参照するデータ
    * DNS Logs
    * CloudTrail
  * 検知結果（Finding）
    * HIGH, MEDIUM, LOWの3種類
  * EC2またはIAMにおける脅威を検出
  * 機械学習による異常検知の仕組み
  * エージェント、センサー、ネットワークアプライアンスは不要

### Amazon Cognito※

### Auto Scaling※

### AWS CloudFormation※

### AWS CloudTrail※

### AWS Elastic Beanstalk※

### AWS KMS※

### AWS Lambda※

### AWS OpsWorks

### AWS Secrets Manager

### AWS Security Token Service(STS)

### AWS Step Functions

### Elastic Load Balancing※

## Security, Identity & Compliance

### AWS Identity and Access Management（IAM）

#### [AWS Identity and Access Management (IAM) Part1](https://www.slideshare.net/AmazonWebServicesJapan/20190129-aws-black-belt-online-seminar-aws-identity-and-access-management-iam-part1)

話の内容

* [IDと認証情報の管理](IDと認証情報の管理)
* アクセス権限の管理

##### IAMとは

* AWSリソースをセキュアに操作するための、認証・認可の仕組みを提供するマネージド・サービス
* 各AWSリソースに対して別々のアクセス権限をユーザーごとに付与できる
* 多要素認証（Multi-Factor Authentication:MFA）によるセキュリティの強化
* 一時的な認証トークンを用いた権限の委任
* 他のIDプロバイダーで認証されたユーザーにAWSリソースへの一時的なアクセス
* 世界中のAWSリージョンで同じアイデンティティと権限を利用可能
  * データ変更は結果整合性を保ちながら全リージョンに伝搬
* AWS　IAM自体の利用は無料

##### AWSリソースにアクセスする仕組み

* AWSリソースのアクションまたはオペレーションに対してリクエストできるユーザーまたはアプリケーションのこと（[IAM の仕組みについて](https://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/intro-structure.html#intro-structure-principal)から参照）
  * ユーザーまたはグループ
  * ロール
  * アプリケーション
* プリンシパルは認証されて、リクエストの内容を確認され、認可できるか判定され、リクエストの中で指定しているアクション/オペレーションを対象のAWSリソースに行う
* 認証で確認されるもの
  * Authentication
  * [AWS Security Token Service(STS)](#aws-security-token-servicests)
  * MFA token
* リクエストの中身
  * アクション
  * リソース
  * プリンシパル
  * 環境データ
  * リソースデータ
* 認可
  * IDベースポリシー
    * Permissions
  * リソースベースポリシー
    * Amazon S3
    * AWS Lambda
  * その他ポリシー
    * permission boudary
    * service control policy
    * access control list
* アクション/オペレーション
  * IAM CreateUser
  * IAM DeleteUser
  * IAM GetUser
  * EC2 RunInstances
  * EC2 StartInstances
  * Amazon S3 CreateBucket
  * Amazon S3 ListBucket
  * ...
* AWSリソース
  * Permissions
  * Instances
  * Endpoints
  * Bucket with objects
  * ...

##### IDと認証情報の管理

###### ベストプラクティス

* AWSアカウントのルートユーザーアクセスキーをロックする
  * ルートユーザーのアクセスキーは削除する
  * すでに持っている場合は削除する
  * ルートユーザーでサインインし、セキュリティ認証情報のページからアクセスキーを削除
    * `memo` ルートユーザーで発行していないか確認した→なかった。あと`ルートユーザーのアクセスキーは、AWS アカウント全体への無制限アクセスを提供します。長期的なアクセスキーが必要な場合は、制限されたアクセス許可を持つ新しい IAM ユーザーを作成し、そのユーザーのアクセスキーを生成することをお勧めします。`と書いていた。
  * ルートユーザーの認証情報を他社に開示したりプログラムに埋め込んだりしない
* 個々のIAMユーザーを作成
  * 個別のIAMユーザーを作成する
  * 必要な場合を除きAWSアカウントのルートユーザー認証情報を使用してAWSにアクセスしない
  * 個別のIAMユーザーを作成するメリット
    * 認証情報を個別に変更（ローテーション）できる
    * アクセス許可をいつでも変更、無効化できる
    * Amazon CloudTrailログからアクションを追跡できる
* ユーザーの強力なパスワードポリシーを設定
  * パスワードに要求される強度とパスワードポリシーを設定できる
    * 最小文字数少なくとも1つの英大文字が必要といった強度
    * パスワードの有効期限、ユーザー自身によるパスワード変更の許可、パスワード再利用禁止の世代数、管理者による期限切れパスワードのリセットなど
  * ルートユーザーのパスワードポリシーには適用されない
* アクセスキーを共有しない
  * 複数人がAWSリソースへのアクセス権を共有したい場合でもアクセスキーは共有しない
  * AWSへのアクセスを必要とするアプリケーションの場合はIAMロールを使用して一時的セキュリティ認証情報を取得する
  * アクセスキーは情報の置き場に注意する
    * GitHubリポジトリ、AMIへの埋め込み、ハードコーディング、プレーンテキストでの保管をするときは要注意
* 特権ユーザーに対してMFAを有効化する
  * ルートユーザーや強い権限を持つIAMユーザーにはMFAを有効化し、通常利用しないようにする
    * MFAデバイスも厳重に管理する
  * MFAデバイスの紛失/盗難/不具合が発生したら、代替の認証要素を使って認証し、新しいMFAデバイスを有効化し、パスワードも変更する

###### AWSアカウントのルートユーザー

AWSアカウントのルートユーザーとは

* そのアカウントのすべてのAWSサービスとAWSリソースすべてに完全なアクセス権を持つユーザー
* AWSマネジメントコーンソールへはAWSアカウントを作成したときのメールアドレス/パスワードでサインイン
* IAMで設定するアクセスポリシーではアクセス許可を制限できない
  * AWS Organizationsのサービスコントロールポリシー（SCP）によってサービスを制限可能
* 極力ルートユーザーを使用しない！
  * とはいえルートユーザーでの認証が必要なタスクもある

ルートユーザーの認証が必要なAWSタスクの例

* ルートユーザーのメールアドレスやパスワードの変更
* IAMユーザーによる課金情報へのアクセスのActivate/Deactivate
* 支払いオプションの変更
* AWSサポートプランの変更
* IAMユーザーへのアクセス許可のリストア
* 無効な制約を設定したAmazon S3バケットポリシーの修正
* 脆弱性診断フォームの提出
* 逆引きDNS申請
* CloudFrontキーペアの作成
* AWSアカウントの解約

アクセスキーとは

* AWSアカウントのルートユーザーまたはIAMユーザーの長期的な認証情報
  * 手動で取り消すまで有効
* アクセスキーとを用いてAWS CLIやAWS SDKなどからリクエストに署名
* アクセスキーID/シークレットアクセスキーで構成される
* 安全なローテーションのために、最大2つのアクセスキーを持つことができる


###### IAMユーザー

* AWSで作成するエンティティ（ユーザーまたはアプリケーション）
* 名前と認証情報で構成される
* IAMユーザーを識別する方法
  * ユーザーの「フレンドリ名」：ユーザー作成時に指定
    * 大文字小文字の区別はないためAcliceとaliceは統一とみなされる
  * ユーザーのARN（Amazon Resource Name）：リソースポリシーのPrincipal要素で指定する
    * 例：arn:aws:iam:01234565789012:user/Alice（ここでは数列とAliceと指定している）
  * ユーザーの一意の識別子：フレンドリ名を再利用したいと祈祷に権限のエスカレーションをさけることができる
    * 例：AIDAJQABLZS4A3QDU576Q
  * 認証情報
    * コンソールパスワード
    * アクセスキー

###### MFA（Multi-Factor Authentication：多要素認証）

* パスワードやアクセスキーによる認証に追加して、セキュリティを強化する仕組み
* AWSがサポートするMFAメカニズム
  * 仮想MFAデバイス：モバイルデバイスまたはコンピュータにインストールされたAuthenticatorアプリケーション（単一のデバイスで複数のトークンをサポート）
  * U2Fセキュリティキー：YubiKeyやその他のU2Fデバイス（単一のセキュリティキーで複数のルートユーザー/IAMユーザーをサポートしていて、手入力は不要）
  * ハードウェアMFAデバイス：Gelmatoトークン（単体でOTPを発行）
* ルートユーザー、IAMユーザーの各IDに個別のMFA設定が可能
* MFA条件をしてしたポリシーを関連付けできる対象
  * IAMユーザーまたはIAMグループ
  * Amazon S3バケット、Amazon SQSキュー、Amazon SNSトピックなどのリソース
  * IAMロールの信頼ポリシー

##### アクセス権限の管理

###### ベストプラクティス

* AWS管理ポリシーを使用したアクセス許可の使用開始
  * AWS管理ポリシーを用いると多くのユースケースですぐにポリシーの適用を開始できる
  * 適切なアクセス権限を付与するにはIAMポリシーの詳細な知識が必要
  * まずはポリシードキュメントの扱いに慣れる
* インラインポリシーではなくカスタマー管理ポリシーを使用する
  * カスタマー管理ポリシーはカスタマイズ可能で再利用性も高く管理面で有利
  * カスタマー管理ポリシーの利点はすべての管理ポリシーを1箇所で感クニンできること
  * インラインポリシーの利用はできるだけ避ける
  * インラインポリシーはカスタマー管理ポリシーをに変換することが可能
* 追加セキュリティに対するポリシー条件を使用する
  * より安全なポリシーの運用のために、Condition要素によってポリシーが有効になる条件をさらに絞り込む
    * リクエストを許容するソースIPアドレスの範囲
    * 日付または時間の範囲
    * MFAデバイスでの認証の要求
    * SSLの使用の要求
* 最小権限を付与する
  * IAMポリシーを作成する場合、タスクの実行に必要なアクセス許可のみ付与する
  * 最小限のアクセス権限から開始し、必要に応じてアクセス権限を追加する
    * あとでアクセス権限を強化するより安全なアプローチ（※最初からゆるくしない）
  * 役立つ情報
  * アクセスアドバイザーのサービスの最小アクセス時間データ
  * Amazon CloudTrailのイベントログ
  * IAMポリシーをのリファレンス
* IAMユーザーへのアクセス許可を割り当てるためにグループを使用する
ポリシーの関連付けを簡単にするためにはIAMグループを利用したほうが便利
組織またはジョブ機能に関連したIAMグループを作成し、IAMグループに対してアクセスIAMポリシーを関連付ける
会社内で組織移動がある場合は、そのIAMユーザーが所属するIAMグループを変更すればよい

###### ポリシー

* IAMアイデンティティやAWSリソースに関連付けることによってアクセス許可を定義できるオブジェクト
* 通常、JSONポリシードキュメントでアクセス条件を記述
* ポリシードキュメントは1つ以上のStatementブロックで構成

###### AWSがサポートするポリシータイプ

* アイディンティティベースポリシー
  * 管理ポリシー
    * 複数のIAMユーザー、IAMグループ、IAMロールに関連付け可能（最大10個）
    * 再利用可能
    * 一元化された変更管理
    * バージョニングとロールバック
    * 種類
      * AWS管理ポリシー
        * AWSにより事前定義された管理ポリシー
        * AWSが作成および管理し、編集負荷
        * すべてのAWSアカウントで利用可能
          * AWSによる管理
            * AmazonEC2FullAccess
            * AmazonS3ReadOnlyAccess
          * ジョブ機能
            * AdministratorAccess
            * SecurityAudit
            * DataScientist
        * AWSにより更新される
      * カスタマー管理ポリシー
        * AWSアカウントで管理することができるカスタムポリシー
        * AWS管理ポリシーでは要件を満たせない場合にカスタマー管理ポリシーを適用
  * インラインポリシー
    * 1つのIAMエンティティ（単一のIAMユーザー、IAMグループ、IAMロール）に直接埋め込むポリシー
    * IAMエンティティに紐付いた固有のオブジェクト
    * IAMエンティティを削除するとインラインポリシーも削除される
    * IAMエンティティとポリシーとの厳密な1対1の関係を維持する必要がある場合などにインラインポリシーを適用する
* リソースベースポリシー
  * AWS IAMロールの信頼ポリシー
  * Amazon S3のバケットポリシー
  * Amazon SNSトピックのアクセス許可
  * Amazon SQSキューのアクセス許可
* パーミッションバウンダリー
  * AWS IAMアクセス許可の協会
  * AWS Organizationsサービスコントロールポリシー（SCP）
* アクセスコントロールポリシー
  * Amazon S3のバケットのACL
  * Amazon VPCのサブネットのACL
* セッションポリシー

###### ポリシードキュメントの主の要素

* Version:ポリシー言語のバージョン。Vesion要素を含めないとポリシー変数（${aws:username}など）は文字列として扱われる
* Statement:アクセス許可に関する複数要素（Effect/Action/Resourceなど）を含むステートメントブロック。複数のステートメントブロックを並べることができる
* Effect:AllowまたはDeny。ステートメントの結果を許可または明示的な拒否にするか指定する
* Principal:リソースベースのポリシー（バケットポリシーや信頼ポリシーなど）に記述する。リソースへのアクセスを許可または拒否するAMAエンティティ（IAMユーザー、フェデレーティッドユーザー（他システムと連携したユーザー？）、IAMロール、AWSサービスなど）をARN形式で指定する。
  * AWSリソースへのアクセスが許可/拒否されるIAMエンティティを指定する
  * リソースベースポリシーで使用
  * AWSアカウント、IAMユーザー、IAMロール、フェデレーティッドユーザー、引き受けたロールユーザー（assumed-role user）をARN形式で記述
    * ユーザーを指定する際にすべてのユーザーの意味でワイルドカード（*）を使用することはできない
  * IAMロールの信頼ポリシーのPrincipal要素に指定したIAMユーザーとIAMロールを削除すると信頼関係は壊れる。
    * 同じ名前でIAMエンティティを作成してもプリンシパルIDが異なるため、同じ名前で再作成した場合はロールの再編集が必要
* Action:Effect要素で許可または拒否する対象となる特定のアクションを記述する。大文字小文字の区別はされない。各AWSサービスを識別する名前空間（iam,ec2,s3など）でサポートされるアクションが定義されている。
  * 許可/拒否される特定のアクションを指定する
  * Statement要素にはAction/NotAction要素が必須
  * AWSサービスで行うことができるタスクを記述する独自のアクションセットを記述
  * 有効なアクション名はドキュメントを参照、またはポリシーエディターから選択
  * 形式："Action":"<各サービスの名前空間>":<アクション名>"
    * "Action":"ec2:StartInstances"
    * "Action":["sqs:SendMessage", "sqs:ReceiveMessage"]
    * "Action":"iam:*AccessKey"
    * "Action":IAM:listaccesskeys"
  * 注：複数のアクションを指定可能、ワイルドカード（*）を使用可能、値は大文字小文字の区別なし
* Resource:Action要素の対象となる特定のリソースをARN形式で記述する。指定したAction（ec2:DescribeInstancesなど）によっては個々のリソースを指定することができず、*（ワイルドカード）を指定する必要がある。
* Statement要素にはResource/NotResource要素が必須
* AWSサービスが持つ一連のリソースセットをARN形式で記述
  * 有効なリソースはドキュメントを参照、またはポリシーエディターから選択
  * "Resource":"arn:aws:sqs:us-east-2:123456789012:queue1"
  * "Resource":"arn:iam:123456789012:user/accounting/*"
  * "Resource":["arn:aws:dynamodb:us-east-2:123456789012:table/books_table",*   "arn:aws:dynamodb:us-east-2:123456789012:table/magagines_table"]
  * "Resource":"arn:aws:dynnamodb:us-easet-2:123456789012:table/${aws:username}"
* 注：複数のリソースを指定可能、ワイルドカード（*）を使用可能、JSONポリシー変数を指定可能
* Condition:ポリシーを実行する条件を指定することができる。Condition要素は条件演算子、ポリシー変数、条件値から構成される
  * ポリシーが有効になるタイミングの条件を指定する
  * Condition要素の記述はオプション
  * 条件キー：条件地に対する評価方法として条件演算子を作用させる演算式を記述
  * 形式：”Condition”:{<条件演算子>:{<条件キー>:<条件値>}}
  * 条件演算子
    * 条件比較のタイプ（文字列条件、数値条件、IPアドレス条件など）を指定する
    * 条件キーごとに使用できる条件演算子の種類が決まっている
  * 条件キー
    * AWSグローバル条件コンテキストキー（"aws:"で始まる）
      * すべてのサービスで使用可能なキー、一部のサービスでのみ使用可能なキーがある
    * AWSサービス固有のキー（そのサービス固有の名前（"s3":など）で始まる）
    * IAMの条件コンテキストキー
    * "Condition":{"StringEquals":{"aws:username":"johndoe"}}
    * "Condition":{"StringEqualsIgnoreCase":{"aws:username":"johndoe"}}
    * "Condition":{"IpAddress":{"aws:SourceIP:["192.0.2.0/24", "203.0.113.0/24"]}}
    * "Condition":{"StringEquals":{"ec2:ResourceTag/tagkey":"tagvalue"}}
    * "Condition":{"StringEquals":{"s3:prefix":"projects"}}
    * "Condition":{"StringEquals":{"iam:PassedToService":"cloudwatch.amazonaws.com"}}
    * "Condition":{"ForAllValues:StringEquals":{"dynamodb:Attributes:["ID", "Message", "Tags"]}}
  * 要素のAND条件OR条件
    * "Condition":{"DateGreaterThan":{"aws:CurrentTime:"2019-01-29T12:00:00Z"},"IpAddress":{"aws:SourceIp":["192.168.176.0/24","192.168.143.0/24]}
      * Condition下のブロックはAND条件、演算子に対する値はOR条件
      * この例の場合、"20219/1/29の12：00よりあとに、ソースIPアドレス"192.168.176.0/24"もしくは"192.168.143.0/24"のネットワークからアクセスしたリクエスト"を意味する
    * 注：条件キーは大文字小文字を区別しない、条件値の大文字小文字の区別は使用する条件演算子によって異なる
  * アクセス可否のロジック
    * 暗黙的なDeny（デフォルト）<明示的なAllow<明示的なDeny
    * すべてのアクセスはデフォルトでDeny
    * アクセス権限にAllowの条件があった場合、アクセス許可
    * ただし、アクセス権限に1つでもDenyの条件があった場合、アクセス拒否（明示的なDeny）
  * IAMポリシーの作成を支援するツール群がある

###### アクセス権の決定ロジック（同一アカウントの場合）

SCP AND (
    アイディンティティベースポリシー（管理ポリシー OR インラインポリシー）
    AND アクセス許可の境界
    ）
    OR リソースベースポリシー
)


* アイディンティティベースのポリシー
  * 管理ポリシーとインラインポリシーのそれぞれで許可されているものが有効な権限となる（OR条件）
* アクセス許可の境界
  * アクセス許可の境界とアイディンティティベースのポリシーの両方で許可されているものが有効な権限となる（AND条件）
* AWS Organizationsサービスコントロールポリシー（SCP）
  * SCPとアイデンティティベースのポリシーの両方で許可されているものが有効な権限となる（AND条件）
* リソースベースポリシー（同一アカウントの場合）
  * 同一アカウントの場合、リソースベースポリシーとアイディンティティベースポリシーのそれぞれで許可されているものが有効となる（OR条件）

###### アクセス権の決定ロジック（クロスアカウントの場合）

SCP AND (
    アイディンティティベースポリシー（管理ポリシー OR インラインポリシー）
    AND アクセス許可の境界
    ）
    AND リソースベースポリシー
)

リソースベースポリシー（クロスアカウントの場合）
クロスアカウントの場合、リソースベースポリシーとアイディンティティベースポリシーの療法で許可されているものが有効となる。

※アカウントが異なるリソースにアクセスをさせたい場合は、個別のアクセス許可（アイディンティティベースポリシー）が必要

##＃# IAMグループ

* IAMグループ：IAMユーザーの集合
* IAMグループやIAMロールをIAMグループに所属させることは不可
* IAMユーザーは複数のIAMグループに所属することができる（最大10）
* IAMグループに関連付けられたIAMポリシーは所属するIAMユーザーに継承される

#### [AWS Identity and Access Management (IAM) Part2](https://www.slideshare.net/AmazonWebServicesJapan/20190130-aws-black-belt-online-seminar-aws-identity-and-access-management-aws-iam-part2)

##### 権限の委任

###### ベストプラクティス

* Amazon EC2インスタンスで実行するアプリケーションに対し、ロールを使用する
  * アプリケーションがAWSサービスにアクセスするためには認証情報が必要
  * 認証情報をEC2（OS/アプリケーション）側に持たせる必要がない、認証情報の漏洩リスクを低減可能
  * IAMロールによる認証情報はAWSが自動的にローテーション
  * AWS SDKによって認証情報取得と有効期限切れ前の再取得を自動的に実施可能
  * AWS CLIもIAMロールに対応済み
  * ※もしIAMユーザーに認証情報を与えると、与えた先で認証情報の保管・ローテーションなどの検討が必要
* ロールを使用したアクセス許可の委任
  * アカウント間でセキュリティ認証情報を共有しない
  * 代わりにIAMロールを付与する


###### IAMロール

* AWSサービスやアプリケーションなどのエンティティに対してAWSリソースの操作権限を付与するための仕組み
  * ユーザーまたはアプリケーションがロールを一時的に引き受けることで関連付けられたアクセス許可を受けることができる
  * IAMユーザーやグループには紐付かない（※IAMロールをみてもどのIAMユーザーやグループに紐付いているかはわからないですよってことかな？）
* 認証方法
  * 一時的なセキュリティ認証情報を利用
* 複数のユーザーがロールを引き受け可能
  * 別のAWSアカウントのIAMユーザー、ロールなど
  * Amazon EC2、AWS LambdaなどのAWSサービス
  * SAML2.0またはOpenID Connect（OIDC）と互換性があるIDプロバイダーによって認証された外部ユーザー

###### 一時的なセキュリティ認証情報

* 有効期限付きのアクセスキーID/シークレットアクセスキー/セキュリティトークンで構成
  * 短期的な有効期限（認証情報を取得する際に期限を設定）
  * 認証情報が不要になったときにローテーションしたり明示的に取り消す必要がない（ユーザー側に認証情報が保存されない）のでより安全
* ユーザーのリクエストによってAWS Security Token Service（STS）が動的に生成

###### AWS Security Token Service（STS）

* 一時的なセキュリティ認証情報を生成するサービス
  * 期限付きのアクセスキー/シークレットアクセスキー/セキュリティトークン
  * トークンのタイプにより有効期限はさまざま
* 発行した認証情報の期限の変更は不可
  * 必要がある場合は、特定の時点より前に発行したロールの認証情報の、すべてのアクセス許可をすぐに取り消し可能
* STSエンドポイントは全リージョンで使用可能
  * デフォルトではグローバルサービスとして利用
  * 各リージョンのSTSエンドポイントでアクティベート可能
    * レイテンシーの低減
    * 冗長化の構築
  * PrivateLinkに対応（2019年ではオレゴンリージョンのみ）
  * アクティベートしたリージョンでCloudTrailを有効化
* STSで利用できる一時的なセキュリティ認証情報を取得するためのAPI Action
* AssumeRole：既存のIAMユーザーの認証情報を用いて、IAM Roleのtemporary security credentialsを取得するためのアクション
* AssumeRoleWithWebIdentity：AmazonやFacebook、Googleによる承認情報を使用してロールを引き受け、temporary security credentialsを取得するためのアクション
* AssumeRoleWithSAML：IdPによる認証とSAMLのアサーションをAWSにポストすることでロールを引き受けtemporary security credentialsを取得するためのアクション
  * ※IdP：Identity ProviderSAMLの認証情報を提供する側のこと。認証情報を利用する側をService Provider（SP）と呼ぶ。
* GetSessionToken：自身で利用するIAMユーザーのtemporary security credentialsを取得するためのアクション
* GetFederationToken：認証を受けたFederatedユーザー（他システムと連携したユーザー？）のtemporary security credentialsを取得するためのアクション


###### ロールを使用したアクセス許可の委任

別のAWSアカウントのユーザーが認証情報を共有せずに、自分のAWSアカウントのリソースにアクセスを制御可能にすることが可能

ユースケース

* IAMロールによるクロスアカウントアクセス
  * あるアカウントのユーザーに別のアカウントのIAMロールを紐付ける機能
  * たとえば開発アカウントを使って本番環境のS3データを更新するときに使用する
    * AWS STSのAssumeRoleで一時的な認証情報を開発アカウントにわたし、本番アカウントのS3ForDevAccountロールの権限でアクセス
  * ロールに誰が引き受けられるか設定し、かつ使う側もロールを使うことを受け入れる設定をする必要がある
  * MFA認証されたユーザーのみロールを使うことができるという設定も可能
* クロスアカウントアクセスにより権限管理を効率化
  * さまざまなアカウントにアクセスするためのアカウントを作成し、それに必要なアカウントのロールを付与するという形にできる
  * SwitchRole
    * IAMユーザーからクロスアカウント用IAMロールにコンソールから切り替える機能
    * 必要なときのみIAMユーザーの権限を昇格させる（sudoみたいなものかな？）
      * IAMユーザーには読み取り権限のみ付与して、IAMロールには更新権限を付与するとか
* SAML2.0ベースのIDフェデレーション
  * 組織内の全員についてIAMユーザーを作成しなくても、ユーザーはAWSを使用可能
  * AssumeRoleWithSAML APIを呼び出す
* SAML2.0ベースのAWSマネジメントコンソールへのシングルサインオン
  * AssumeRoleWithSAML APIを直接呼び出す代わりにAWS SSOエンドポイントを使用する必要がある
* Amazon　Cognitoを用いたモバイルアプリのWebIDフェデレーション
  * モバイルアプリから一時的なAWSセキュリティ認証情報を必要に応じて動的にリクエスト
  * 認証を管理するサーバーは不要で、たとえばスマートフォンとS3だけでシステムを作成可能
  * Google Amazon Twitter Facebook Amazon CognitoおよびOIDC準拠のIdPに対応


#####  IDと権限のライフサイクル管理

###### ベストプラクティス

* AWSアカウントのアクティビティを監視
  * AWSのロギング機能を有効にすることで確認できるようになる
  * ログファイルにはアクション日時や、アクションのソースIP、不適切なアクセス許可のために失敗したアクションなどが示される。
* アクセス権限を使用して、IAM権限を確認する
  * AWSアカウントのセキュリティを向上させるために、IAMポリシーを定期的にみなおす
    * アクセスアドバイザーを利用し、ポリシーにおいて、必要なアクションにのみ必要最小限の権限が付与されていることを確認する
    * ポリシーのポリシー使用状況を確認し、適用されているユーザやグループ、ロールを確認する
    * 「アクセス権限」で最小権限か確認する
* 不要な認証情報を削除する
  * パスワードやアクセスキーのローテーションなど、認証情報ライフサイクルの要件の結果を監査する
    * コンソールを使用しないIAMユーザにはパスワードを設定しない
    * 最近使用していないパスワード、アクセスキーは削除の対象。
  * 社員の入退社、部署の異動や役割の変更など、人員のライフサイクルと連動させる
  * 認証情報レポートはダウンロード可能
* 認証情報を定期的にローテーションする
  * IAMユーザーのパスワードローテーション
    * IAMのパスワードポリシーでユーザーがパスワードを変更できるようにする
    * パスワードの有効期限を設けておくことでユーザーが定期的にパスワードをローテーションするようにする
  * アクセスキーのローテーション
    * IAMユーザーの「認証情報」の「アクセスキー」から「アクセスキーの管理」を選択
    * 「アクセスキーの作成」で新しい認証情報を作成（2つまで）
    * 新しい認証情報でテストを行い、古いキーはInactiveにする
      * 万が一問題がおきたときは再びActivateする

###### AWSアカウントのアクティビティの監視

* AWSアカウントのアクティビティの監視とは、たとえばAWS CloudTrailを使う。
* AWS CloudTrail：AWSアカウントで行われたAWS APIコールおよび関連イベントを記録
* AWSのリソースにどのような操作を加えられたか記録に残す機能であり、全リージョンでの有効化を推奨。
* 適切なユーザーが与えられた権限で環境を操作しているかの確認と記録に使用。

###### アクセスレベルを使用してIAM権限を確認する

アクセスレベルとは？

1. リスト
2. 読み込み
3. 書き込み
4. アクセス権限の管理

ポリシー概要にサービスが含まれる場合、そのアクセスレベルを定義する（？）

アクセスアドバイザー

* IAMエンティティ（ユーザー、グループ、ロール）が最後にAWSリソースにアクセスした日付と時刻を表示する機能。
* IAMの最小限の権限に関する設定に利用。

###### 不要な認証情報を削除する

IAM認証情報レポートは以下の情報を参照できる。4時間に1回生成可能。

* ユーザーの作成日時
* 最後にパスワードが使用された日時
* 最後にパスワードが変更された日時
* MFAの利用をしているか
* AccessKeyがアクティブか
* etc.

###### 認証情報を定期的にローテーションする

#### [IAM の仕組みについて](https://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/intro-structure.html#intro-structure-principal)

TODO